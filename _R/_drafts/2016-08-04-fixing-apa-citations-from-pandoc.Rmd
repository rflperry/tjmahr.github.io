---
layout: post
title: "Fixing APA citations from Pandoc with stringr"
excerpt: 
share: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Pandoc is awesome. Truly the Swiss Army knife of plain-text documents. I like
especially like that it can do inline citations. I write `@Jones2005 proved
aliens exist` and pandoc produces "Jones (2005) proved aliens exist".

But it doesn't quite do APA style citations correctly. A citation like
`@SimpsonFlanders2006 found...` will be rendered as "Simpson & Flanders (2006)
found...`. Inline citations are not supposed to have ampersands in the list of
authors. It should be `Simpson & Flanders (2005) found...`.

This is tedious low-level stuff, but I have colleagues who will read a draft of
a manuscript and write unnecessary comments about to cite stuff in APA. And it's
too pervasive for one to fix manually. My current project has 15 of these ill-
formatted citations. That number is just big enough to make manual corrections
too much of a hassle and error-prone---easy to miss 1 in 15.

This script demonstrates a quick R function I wrote that replaces all those
inline ampersands with "and"s. 

## It's just regular expressions

We'll be doing a lot of regular expression patterns, prefixed with `re_`. Let's
assume that an inline citation consists of an author's last name followed by a
parenthesized year: `SomeKindOfName (2001)`. We encode these assumptions into
regular expression patterns, prefixed with `re_`. 

The year is pretty easy. If it looks weird, it's because I prefer to escape
special punctuation like `(` using brackets like `[(]`. Otherwise, four digits:
`\\d{4}`.

```{r}
library("stringr")
re_inline_year <- "[(]\\d{4}[)]"
```

**What's in a name?** Here we have to stick our necks a little bit more about
our assumptions. I'm going to assume a last name is any combination of letters,
hyphens and spaces (spaces needed `von Name`). 

```{r}
re_author <- "[[:alpha:]- ]+"
re_author_year <- sprintf("(%s %s)", re_author, re_inline_year)
```

Next, we find the ampersand. We allow for a comma to precede in case there are
more than two authors.

```{r}
re_maybe_comma <- "(,?)"
re_ampersand <- "( & )"
re_ampersand_author_year <- "%s%s%s" %>%
  sprintf(re_maybe_comma, re_ampersand, re_author_year)
```

These regular expressions are wrapped in parentheses so that I can use
backreferences. During something like `str_replace("hotdog", "(hot)(dog)", "\\2\
\1")`, you can refer to things captured by parenthesized patterns like `(hot)`
with escaped digits like `\\1`. In that example, we reorder the patterns `(hot)
(dog)` via `\\2\\1` to get `doghot`. For the current example, we just replace
the second group which captures ` & ` with ` and `.

```{r}
replace_inline_ampersand <- . %>%
  str_replace_all(re_ampersand_author_year, "\\1 and \\3")
```

We can now text our function on a variety of names that it should _and should
not_ fix.

```{r}
test_names <- c(
  "Jones & Name (2005) found...",
  "...have been found (Jones & Name, 2005)",
  "Jones & Hyphen-Name (2005) found...",
  "...have been found (Jones & Hyphen-Name, 2005)",
  "Jones & Space Name (2005) found...",
  "...have been found (Jones & Space Name, 2005)",
  "Marge, Maggie, & Lisa (2005) found...",
  "...have been found (Marge, Maggie, & Lisa, 2005)")

replace_inline_ampersand(test_names)
```

### Steps towards production

These are complications that arose as I tried to use the function on an actual manuscript:

**Placing it in a build pipeline**. Because this function post-processes output
from pandoc, I can't just hit the "Knit"" button in RStudio. I had to make a
separate script to do `rmarkdown::render` to convert my .Rmd file into a .md
which can then be processed by this function.

**Don't fix too much**: When pandoc does your references for you, it also does
a bibliography section. But do not fix the ampersands there. So I have
to do a bit of fidgeting of finding the line `"## References"` and processing
just the text up until that line.

**Accounting for encoding**. I use `readr::read_lines` and
`stringi::stri_write_lines` to read and write the text file to preserve the
encoding of characters. (readr just released its own `write_lines` today
actually, so I can't vouch for it yet.)

I Use a separate script (e.g., `compile_script.R`) to compile
* read the input with readr::read_lines
