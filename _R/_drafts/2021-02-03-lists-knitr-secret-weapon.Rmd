---
title: Lists are my secret weapon for reporting stats with knitr (2021-02-03)
excerpt: ''
tags: ''
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(magrittr)
n_trees <- length(levels(nlme::Spruce$Tree))
n_plots <- length(levels(nlme::Spruce$plot))
knitted_when <- format(Sys.Date())
knitted_where <- knitr::current_input()
knitted_with <- packageVersion("knitr")
knitted <- list(
  when = format(Sys.Date()),
  where = knitr::current_input(),
  with = packageVersion("knitr")
)

tab <- function(x) {
  split <- x %>% 
    stringr::str_split("[$]") %>% 
    getElement(1)
  
  if (length(split) == 1) {
    results <- .DollarNames(sys.frame(), split[1])
  } else {
    last <- split[length(split)]
    but_last <- split[-length(split)] %>% 
      paste0(collapse = "$")
    results <- paste0(but_last, "$", .DollarNames(get(but_last), last))
  }
  cat(results, sep = "\n")
}


# tab <- function(x, .) cat(utils:::normalCompletions(x), sep = "\n")

"knitted_" %>% tab()
"knitted$wi" %>% tab()

```

I am going to describe my most important trick for reporting inline
stats in knitr. Inline reporting happens when you insert R expressions
inside of markdown text. Those expressions are evaluated and their
results are plugged in as text. The following example shows a common use
case: Reporting descriptive statistics.


````md
```{r}`r ''`
library(magrittr)
n_trees <- length(levels(nlme::Spruce$Tree))
n_plots <- length(levels(nlme::Spruce$plot))
```

The dataset contains `r knitr::inline_expr("nrow(nlme::Spruce)")` measurements 
from `r knitr::inline_expr("n_trees")` trees grown in `r knitr::inline_expr("n_plots")` plots.
````

which produces

````md
The dataset contains `r nrow(nlme::Spruce)` measurements 
from `r n_trees` trees grown in `r n_plots` plots.
````

If we update the dataset, the numbers will update automatically when the
document is reknitted. It's just magical. Besides reporting statistics,
I routinely use inline reporting for package versions, dates, file
provenance, and emoji.

````md
```{r}`r ''`
knitted_when <- format(Sys.Date())
knitted_where <- knitr::current_input()
knitted_with <- packageVersion("knitr")
```

Reported prepared on `r knitr::inline_expr("knitted_when")` from ``r knitr::inline_expr("knitted_where")`` 
with knitr version `r knitr::inline_expr("knitted_with")` `r knitr::inline_expr("emo::ji('happy')")`. 

::::

Reported prepared on `r knitted_when` from ``r knitted_where`` 
with knitr version `r knitted_with` `r emo::ji("happy")`. 
````

## Are your variable names doing a list's job?

In this last example, I used prefixes in variable names to convey that
the data were related. `knitted_when`, `knitted_where` and
`knitted_with` are all facts about the knitting process. They are all
reported inline close to each other. The prefix informally bundles them
together. The prefix also helps with writing our code because we have to
remember less. We can type `knitted_` and press <kbd>TAB</kbd> and let
autocompletion remind us which variables are available.


```{r}
"knitted_" %>% tab()
```






What if we change that underscore `_` into a dollar sign `$`,
so to speak?


```{r}

```



```{r, include = FALSE}
.parent_doc <- knitr::current_input()
```
```{r, xchild = "_footer.Rmd"}
```
