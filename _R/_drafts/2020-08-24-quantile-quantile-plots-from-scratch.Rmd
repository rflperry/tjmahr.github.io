---
title: QQ-Plots from Scratch (2020-08-24)
excerpt: Less q q, more pew pew
tags: ''
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  fig.asp = NULL
)

knitr::opts_template$set(
  qq1 = list(fig.width = 3.5, fig.height = 3, out.width = "66%")
)
knitr::opts_template$set(
  qq3 = list(fig.width = 6, fig.height = 5, out.width = "80%")
)
```

*update date when published*

*figure out style for "QQ Plot"*

Goals

- create a quantile quantile plot from scratch
- create a worm plot from scratch
- create StatWorm
- report history of QQplot?


One of the things I have come to appreciate is how programming is a great way to
learn statistics. My eyes will glaze over at a series of equations in a
derivation, but ask me to program the procedure, I'll never forget how it works.
This post will be one of those exercises where we program a statistical tool
from scratch to learn how it works.

A quantile-quantile plot, or a Q-Q plot, is a way to compare two distributions
of data. These plots are a common diagnostic tool when we need to check a
distributional assumption. For example, residual errors from a linear regression
model should normally distributed, and indeed, one of the pre-made diagnostic
plot for an lm model is Q-Q plot.

```{r example-qq, fig.width = 4, fig.height = 3.5, out.width = "66%", fig.cap = "A diagnostic Q-Q plot for a linear model."}
plot(lm(mpg ~ wt, mtcars), which = 2, id.n = 0)
```

Reading these plots is a bit of an art, but Sean Kross provides [a tutorial on
how to interpret these
plots](https://seankross.com/2016/02/29/A-Q-Q-Plot-Dissection-Kit.html) and
walks through a few examples of "bad" Q-Q plots. 

In this post, we are going to make Q-Q plots from scratch.




## The Q-Q points are easy to calculate

Fox (2016, p. 38--39) provides a step-by-step procedure to building a Q-Q plot
and provides a great implementation in his package with `car::qqPlot()`. His
procedure will be the basis for the math in this code.

The first step is to convert ranks into quantiles. One naive approach might be
dividing ranks by the length:

```{r}
# generate data for this post
set.seed(20200825)
x <- sort(rnorm(20, 10, 3))

# naive quantiles
rank(x) / length(x)
```

With 20 observations, 1 point is 5% of the data, so the quantiles increase by
.05 with each step from .05 to 1.00. The problem here is that we get a quantile
of 1. When we look up the quantiles from theoretical distributions, **quantiles
of 0 and 1 break things**:

```{r}
# 0 and 1 quantiles of a normal distribution
qnorm(c(0, 1))
```

Instead, we will adjust the ranks by 1/2, so that the quantiles are "centered"
in their .05 bin. That is, the first quantile of .05 will become .025.

```{r}
q <- (rank(x) - .5) / length(x)
q
```

R provides a function for this purpose, `ppoints()`, but it includes extra
smarts for when there are 10 or fewer values. Otherwise, it does the same
adjustment by .5 that we are using.

```{r}
ppoints
```

Given these quantiles, we can look up what values have these quantiles in
various distribution. For
example, for a normal distribution with a mean of 100 and standard deviation
of 15, the corresponding quantiles would be:

```{r}
round(qnorm(q, 100, 15), 1)
```

Or, more to the point, we can project our observed data onto a normal
distribution with the same mean and standard deviation as our data.

```{r}
qnorm(q, mean(x), sd(x))
```

Let's bundle things into a dataframe and start making some plots.

```{r qq1, opts.label = "qq1", fig.cap = "A Q-Q plot by using `qnorm(ppoints(length(x)), mean(x), sd(x))`, more or less."}
library(tibble)
library(ggplot2)

d <- tibble(
  x = x, 
  quantile = ppoints(length(x)),
  x_theoretical = qnorm(q, mean(x), sd(x))
)

ggplot(d) + 
  geom_point(aes(x = x_theoretical, y = x)) +
  labs(
    x = "theoretical quantiles", 
    y = "sample quantiles"
  )
```

If we project onto the *z*-score distribution---that is, a "unit normal", a
normal with mean 0 and standard deviation 1---our points (black) perfectly match the Q-Q plot
provided by ggplot2 (red points):

```{r qq2, opts.label = "qq1", fig.cap = "A Q-Q plot by using `qnorm(ppoints(length(x)), 0, 1)`."}
d$z_theoretical <- qnorm(d$quantile, 0, 1)

ggplot(d) + 
  geom_point(aes(x = z_theoretical, y = x), size = 3) +
  geom_qq(aes(sample = x), color = "red") + 
  labs(
    x = "theoretical quantiles", 
    y = "sample quantiles"
  )
```

### A math-less description of what we are doing

We can think of this quantile-quantile procedure in terms of database operations:

  - Start with two tables `a` and `b` with the name numbers of rows
  - For each one, create a `quantile` "index" for the value of interest.
  - Now join the datasets using the quantile index: `left_join(a, b, by =
    "quantile")`

If `a` and `b` were tables of real-life collected data, that's the procedure we would
follow. For Q-Q plots, however, the second dataset `b` almost always isn't a
table of observations. Instead, we "look up" of the values using math by
computing values from a theoretical distribution. 

Fox provides a math-ful description of what we do with the quantiles: We "use
the inverse of the CDF [cumulative distribution function] (i.e., the *quantile
function*) to find the value $z\_i$ corresponding to the cumulative probability
$P\_i$.


## The Q-Q line is trickier

Q-Q plots usually come with a reference line so that we can assess whether the
two sets of quantiles follow a linear trend. For a long time, I always thought it was
the line $y = \mathrm{mean} + \mathrm{SD}* x$. But that is not the case:

```{r qq3, opts.label = "qq3"}
p <- ggplot(d) + 
  geom_point(aes(x = z_theoretical, y = x)) + 
  geom_abline(
    aes(intercept = mean, slope = sd, color = "Naive: mean + SD * x"),
    data = tibble(sd = sd(d$x), mean = mean(d$x))
  ) +
  geom_qq_line(
    aes(sample = x, color = "R: Something else"),
    # use the abline glyph in the legend
    key_glyph = draw_key_abline
  ) +
  labs(
    color = "Q-Q line",
    x = "theoretical", 
    y = "observed"
  ) + 
  guides(color = guide_legend(nrow = 1)) +
  theme(legend.position = "top", legend.justification =  "left")
p
```

This recent discovery mystified me. This line from the help page for `qqpline()` offered a clue:

> `qqline` adds a line to a “theoretical”, by default normal, quantile-quantile
> plot which passes through the probs quantiles, by default the first and third
> quartiles.

Indeed, if we draw points at the .25 and .75 quantiles, we can see that the they
land on R's Q-Q line.


```{r, fig.width = 6, fig.height = 4}
anchors <- tibble(
  x = qnorm(c(.25, .75)),
  y = quantile(d1$x, c(.25, .75))
)

p + 
  geom_point(
    aes(x = x, y = y), 
    data = anchors, 
    shape = 3, 
    size = 5, 
    stroke = 1.1, 
    color = "blue"
  )
```

Indeed, Fox explains that this is a "robust" estimate for the line: 

> We can alternatively use the median as a robust estimator of [the mean] and
> the interquartile range / 1.349 as a robust estimator of [the standard
> deviation]. (The more conventional estimates [of the sample mean and SD]
> will not work well when the data are substantially non-normal.) [p. 39].

We can confirm the previous plot by updating the previous plot.

```{r}
p + 
  geom_abline(
    aes(intercept = mean, slope = sd, color = "Robust: median + IQR / 1.349  * x"),
    data = tibble(sd = IQR(d1$x) / 1.349, mean = median(d1$x))
  ) 
```

## A confidence band helps

One problem with these Q-Q plots is that it is hard to tell whether the points
are straying too far away from the line. We can include a 95% confidence band 
to the interpretation. Fox provides an equation for the standard error for a sorted variable.

We want these points to along the same line, but the quantiles in the tails will be a little noisier than the ones in the middle. 

```{r}
se_sorted <- function(z, sd, n) {
  dens_weighted <- sd / dnorm(z)
  dens_weighted * sqrt(pnorm(z) * (1 - pnorm(z)) / n)
}

band <- tibble(
  z = seq(-2.2, 2.2, length.out = 300),
  robust_sd = IQR(d1$x) / 1.349,
  mu = mean(d1$x) + z * sd(d1$x),
  mu2 = median(d1$x) + z * IQR(d1$x) / 1.349,
  se = se_sorted(z, sd(d1$x), length(d1$x)),
  robust_se =  (robust_sd / dnorm(z)) * 
    sqrt(pnorm(z) * (1 - pnorm(z)) / length(d1$x))
)

p + 
  geom_ribbon(
    aes(x = z, ymax = mu + 2 * se, ymin = mu - 2 * se), 
    data = band, 
    fill = NA, 
    color = "black"
  )
```


Fox provides an implementation in the car package. Let's check our work. We can confirm that his confidence bands are based on 


## Worm plots 

Finally, I would like to implement my preferred alternative to Q-Q plot: the worm plot *caterpillar*. 
I first encountered these in [the gamlss package](todo). The idea is nice: The Q-Q plot wastes a lot of vertical space showing a line go upwards. If we remove that line, then we can devote the vertical space in the plot for showing the deviation around that line. It increases the dynamic range of the Q-Q plot.

```{r}
knitr::opts_chunk$set(eval = FALSE)
```


I would like to implement a basic normal-family worm plot in ggplot2 so that I
can call `stat_worm()` and `stat_worm_band()`. First, let's create the `layer()`
functions. I copy the `stat_qq()` source code and tweaked it to remove options for other
distributions and I set the stat to `StatWorm`.

```{r}
stat_worm <- function(
  mapping = NULL, 
  data = NULL,
  geom = "point", 
  position = "identity",
  ...,
  global = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
) {
  layer(
    data = data,
    mapping = mapping,
    # the important line
    stat = StatWorm,
    geom = geom,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      global = global,
      na.rm = na.rm,
      ...
    ),
  )
}

```


Now we create the `StatWorm`.

```{r}
StatWorm <- ggproto(
  "StatWorm", 
  Stat,
  default_aes = aes(
    y = after_stat(sample), 
    x = after_stat(theoretical)
  ),

  required_aes = c("sample"),

  setup_data = function(data, params) {
    data$global_n <- nrow(data)
    data$global_mean <- mean(data$sample)
    data$global_sd <- sd(data$sample)
    data$global_q <- ppoints(nrow(data))
    data
  },
  
  compute_group = function(data, scales, global = FALSE) {
    sample <- sort(data$sample)
    n <- length(sample)
    
    if (global) {
      quantiles <- sort(data$global_q)
      mean <- data$global_mean[1]
      sd <- data$global_sd[1]
    } else {
      quantiles <- ppoints(n)
      mean <- mean(sample)
      sd <- sd(sample)
    }
    scaled_theoretical <- qnorm(quantiles, mean, sd)
    theoretical <- qnorm(quantiles)
 
    data.frame(
      # sample_raw = sample,
      sample = sample - scaled_theoretical, 
      theoretical = theoretical
    )
  }
)

```


```{r}
d1$groups <- rep(c("a", "b"), 10)
ggplot(d1) + 
  stat_worm(aes(sample = x), global = TRUE) + 
  facet_wrap("groups")
ggplot(d1) + 
  stat_worm(aes(sample = x), global = FALSE) + 
  facet_wrap("groups")

ggplot(d1) + 
  stat_worm(aes(sample = x), global = FALSE)

global <- TRUE
data <- StatWorm$setup_data(data.frame(sample = d1$x))

StatWorm$compute_group(data.frame(sample = d1$x))
```




```{r}
```



```{r}
actual <- tibble(
  x = sort(x), 
  quantile = (rank(x) - .5) / length(x)
)

theoretical <- tibble(
  id = 1:20,
  quantile = (rank(id) - .5) / length(id),
  z = qnorm(quantile)
)

dplyr::left_join(actual, theoretical, by = "quantile")
```



```{r}
library(tibble)
library(ggplot2)


# Fox book page 38
d <- tibble(
  x, 
  z = as.vector(scale(x)), 
  i = rank(x), 
  p = (i - .5) / length(x), 
  q = qnorm(p)
)

ggplot(d) + stat_ecdf(aes(x = z)) + stat_function(fun = pnorm)
ggplot(d) + geom_point(aes(x = q, y = x))
ggplot(d) + geom_point(aes(x = q, y = z)) + geom_abline() 

mu = mean(x)
s2 = IQR(x) / 1.349
ggplot(d) + geom_point(aes(x = q, y = x)) + geom_abline(intercept = mu, slope = sd(x)) + geom_abline(intercept = mu, slope = s2, color = "blue") + geom_qq_line(aes(sample = x, color = "qq"))


ggplot(d) + geom_qq(aes(sample = z)) + geom_qq_line(aes(sample = z)) + geom_abline()
d2 <- qqnorm(x, plot.it = FALSE)

d2$x == d$q

qqline(x)

```


wikipedia uses an en-dash 

Q–Q (quantile-quantile) plot

https://en.wikipedia.org/wiki/Q%E2%80%93Q_plot


https://en.wikipedia.org/wiki/Normal_probability_plot

https://en.wikipedia.org/wiki/Rankit

this post https://seankross.com/2016/02/29/A-Q-Q-Plot-Dissection-Kit.html defines a quantile, provides examples of deviation and interpretation and take aways. 



```{r}



StatWorm$compute_group(data.frame(sample = 1:10))

ggplot(d1) + 
  aes(sample = x) +
  stat_qq() +
  stat_qq(distribution = "qcauchy", color = "pink")
```

