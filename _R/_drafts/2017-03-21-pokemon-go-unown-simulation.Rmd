---
title: Simulating Unown encounter rates in Pokemon Go
excerpt: 'Doing the same thing over and over again'
tags: 
  - r
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

_Pokemon Go_ is that obnoxious augmented reality game where people with
smartphones walk around and catch Pokemon. On February 16, 2017, a second
"generation" of Pokemon were released into the wild, adding dozens of new
species to the game. 

The [rarest among this new 
generation](http://www.imore.com/how-to-catch-unown-pokemon-go) is **Unown**. 
Moreover, as part of a cruel scheme meant to torture completionists, Unown comes
in 26 varieties---one for each letter of the alphabet. Which brings us to the
statistical question behind this blog post: **How long will it take to
encounter all 26 types of Unowns (taking into account repeats)?** Somewhat more
formally, how many random encounters (i.e., draws while sampling with 
replacement) will it take until we have encountered all 26 Unowns?

This general problem is called the **coupon collector's problem**.
[Wikipedia](https://en.wikipedia.org/wiki/Coupon_collector's_problem) includes a
table which says that the expected number of encounters for _n_ = 26 is E(26) =
101. So problem solved?

But not quite. Suppose we had never heard of coupon collector's problem. Suppose
also that we want to get a sense of the uncertainty around the expected value.
For example, how many encounters will it take for the unfortunate travelers in
the 95th percentile?


***

When analytic solutions are difficult or tedious, we can write simulations and get very good approximations. 

First, we write a function to simulate a single successful set of Unown
encounters. The main workhorse is `sample(..., replace = TRUE)`. Using the R's
built-in `LETTERS` constant we can simulate a batch of Unown encounters using 
`sample()`.

```{r}
sample(LETTERS, size = 1, replace = TRUE)
sample(LETTERS, size = 5, replace = TRUE)
sample(LETTERS, size = 10, replace = TRUE)
```

The question then is how many draws from this sample does it take to get the 26
different Unowns. An absolute, and frankly miraculous, lower bound on this
number would be 26. So let's draw 26 samples.

```{r}
set.seed(252)  # For reproducble blogging
n_unique <- function(...) length(unique(...))

first_batch <- sample(LETTERS, size = 26, replace = TRUE)
first_batch
n_unique(first_batch)

leftover <- 26 - n_unique(first_batch)
leftover
```

We got `r unique(first_batch)` unique ones from the first batch of samples The 
lower bound is now `r leftover`, so let's sample `r leftover` more encounters.

```{r}
second_batch <- sample(LETTERS, size = leftover, replace = TRUE)
second_batch

both_batches <- c(first_batch, second_batch)
n_unique(both_batches)

leftover <- 26 - n_unique(both_batches)
leftover
```

We've gotten `r n_unique(both_batches) - n_unique(first_batch)` new ones, and we
have encountered `r n_unique(both_batches)` unique ones from
`r length(both_batches)` total draws. That means the lower bound is now 
`r leftover`.

```{r}
third_batch <- sample(LETTERS, size = leftover, replace = TRUE)
third_batch

all_batches <- c(both_batches, third_batch)
n_unique(all_batches)

leftover <- 26 - n_unique(all_batches)
leftover
```

We've gotten `r n_unique(all_batches) - n_unique(both_batches)` new ones, and we
have encountered--ACTUALLY, this is starting to get tedious. We all know where 
this is going: Take a sample, see how many you have left to get, take another 
sample of that size, etc. Pretty simple? Good! Now, I don't have to explain how
the `while` loop inside this function works.

```{r}
simulate_unown <- function() {
  n_unique <- 0
  target <- 26
  encountered <- character(0)
  
  # Take 26 samples on first iteration, 26 - n_unique on next iteration, etc.
  while (target - n_unique > 0) {
    batch <- sample(LETTERS, size = target - n_unique, replace = TRUE)
    encountered <- c(encountered, batch)
    n_unique <- length(unique(encountered))
  }
  
  length(encountered)
}
```

Each call of the function simulates a process of encountering all 26 unowns,
returning how many samples it took overall to encounter them all.

```{r}
simulate_unown()
simulate_unown()
simulate_unown()
```

Now, we can use `replicate()` to call this function thousands of times.

```{r}
simulations <- replicate(10000, simulate_unown())
```

We can get summary statistics and other quantiles for these simulations

```{r}
summary(simulations)
quantile(simulations, probs = c(.05, .10, .25, .75, .90, .95))
```

The mean in our simulations `r mean(simulations)` is very close to the analytic 
solution of 101. The median `r median(simulations)` is less than the mean, which
is a bit of good news: More than half of players will hit 26 in less than the 
expected 101 encounters. There is a bit of a tail to these simulations, as the
RNG gods have cursed one player by requiring `r max(simulations)` encounters.


```{r}
library(ggplot2)
ggplot(data.frame(x = simulations)) + 
  aes(x = x) + 
  geom_histogram(binwidth = 5, color = "white", center = 102.5) + 
  labs(x = "Num. Unowns encountered until 26 unique Unowns encountered", 
       y = "Num. samples in 10,000 simulations")
```










```{r}

```







I haven't seen any Unown since the update went live last month, so it would proba

I
certainly haven't seen one yet in the month since the update went live. 
Moreover, in a cruel move against completionists, 





*** 

Note about ARM.



I first had this framework impressed on me last year by Gelman and Hill's textbook. When models, for instance, are working with log-odds.... Put another way, 

The simplicity of the 

See also Statistics For Hackers: "If you can write for loops, you can do statistics".
https://speakerdeck.com/jakevdp/statistics-for-hackers
