---
title: Draft post (2018-05-23)
excerpt: ''
tags: ''
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Here's the problem. I have some nested data. It's like there's a lot of little
datasets inside my data. I want to see what a handful of those datasets looks
like.

For example, suppose we want to visualize the top 50 female baby names over
time. I start by adding the number of births for each name, find the top 50 most
populous names, and then keeping just the time series from those top 50 names.

```{r}
library(ggplot2)
library(dplyr, warn.conflicts = FALSE)

babynames <- babynames::babynames %>% 
  filter(sex == "F")

top50 <- babynames %>% 
  group_by(name) %>% 
  summarise(total = sum(n)) %>% 
  top_n(50, total) 

totals <- babynames %>%
  # keep just rows in babynames that match a row in top50
  semi_join(top50) %>%
  group_by(name) %>%
  mutate(
    total_n = cumsum(n),
    prop_born = total_n / sum(n)) %>%
  ungroup()    
```

Hmm, so what does this look like?

```{r}
ggplot(totals) + 
  aes(x = year, y = n) + 
  geom_line() + 
  facet_wrap("name")
```

Aaack, I can't read anything! Can't I just see a handful of them?

This is a problem I face frequently, so frequently that I wrote a proper helper
function to handle this problem. I call it `sample_n_of()`, which is not a very
cool name, but it works. Below I'm going to call it from my personal R package
and keep just the data from four of the names.

```{r}
totals %>% 
  tjmisc::sample_n_of(4, name) %>% 
  ggplot() + 
    aes(x = year, y = n) + 
    geom_line() + 
    facet_wrap("name")

```

In this post, I briefly describe how this functions works using tidy evaluation.
It's not terribly complicated. It relies on some light tidy evaluation plus one
obscure dplyr function.

***

Let's start with the function that we want to write: 

```{r, eval = FALSE}
sample_n_of <- function(data, size, ...) {
  # quote the dots
  dots <- quos(...)
  
  # ...now make things happen...
}
```

where `...` means a variable number of column names. 

For interactive testing, suppose our dataset are the time series from top 50
names and we want data from 5 of the names. In this case, the values for the
arguments would be:

```{r}
data <- totals
size <- 5
dots <- quos(name)
```

A clean way to think about this problem is that we want to sample subgroups of
the dataframe. First, we create a grouped version of the dataframe using
`group_by()`.

The function `group_by()` also takes a `...` argument where the dots are the
typically names of columns in the dataframe. We want to take the names inside of our `dots` and plug them in to where the `...` goes in `group_by()`. This is what the tidy evaluation/rlang world calls *splicing*.

How many things are in dots?

```{r}
count_dots <- function(...) length(quos(...))
count_dots()
count_dots(1, 2, 3)
my_dots <- quos(1, 2, 3)

# it's counting just the one thing
count_dots(my_dots)

# but here it's spliced
count_dots(!!! my_dots)
```

We use `!!! dots` to splice in our `dots` values into the dots needed by `group_by()`.



```{r}
group_by(data, n < 10)
grouped <- data %>% 
  group_by(!!! dots)
```

There is a helper function buried in dplyr called
`group_indices()` which returns the grouping number for each row a grouped
dataframe.

```{r}
grouped %>% 
  tibble::add_column(group_indices(.)) 
```

Then we can sample three of the groups.

```{r}
unique_groups <- unique(group_indices(grouped))
sampled_groups <- sample(unique_groups, size)
sampled_groups

subset_of_the_data <- data %>% 
  filter(group_indices(grouped) %in% sampled_groups)
subset_of_the_data

subset_of_the_data %>% 
  distinct(name)
```

Here's a side-note... Note that the `filter()` here does not use any of the
columns in the dataframe `data`. `group_indices(grouped) %in% sampled_groups`
returns a vector the same length as the number of rows in `data` This same
principle is how `filter(data, FALSE)` returns a 0-row version of a dataframe.




Putting these steps together, we get:

```{r}
sample_n_of <- function(data, size, ...) {
  dots <- quos(...)
  
  group_ids <- data %>% 
    group_by(!!! dots) %>% 
    group_indices()
  
  sampled_groups <- sample(unique(group_ids), size)
  
  data %>% 
    filter(group_ids %in% sampled_groups)
}
```

We can test that the function works as we might expect. Sampling 10 names
returns the data for 10 names.

```{r}
ten_names <- data %>% 
  sample_n_of(10, name) %>% 
  print()

ten_names %>% 
  distinct(name)
```

We can sample multiple columns at once. Ten combinations of names and years show
return ten rows.

```{r}
data %>% 
  sample_n_of(10, name, year) 
```


```{r}

# 
# 
# # ggplot(totals) + 
# #   aes(x = year, y = prop_born) + 
# #   geom_line() + 
# #   facet_wrap("name")
# 
# percentile_years <- totals %>% 
#   group_by(name) %>% 
#   filter(abs(prop_born - .5) == min(abs(prop_born - .5))) %>% 
#   ungroup()
# 
# ggplot(percentile_years) + 
#   aes(x = year, y = prop_born) + 
#   ggrepel::geom_text_repel(aes(label = name))
# 
# peak_year <- totals %>% 
#   group_by(name) %>% 
#   filter(n == max(n)) %>% 
#   ungroup()
# 
# ggplot(peak_year) + 
#   aes(x = year, y = n) + 
#   ggrepel::geom_text_repel(aes(label = name))
```

